#!/usr/bin/env python3

import argparse

parser = argparse.ArgumentParser(description='plot simulation results')
parser.add_argument('-o', action='store', dest='outdir', help='output directory', default='')
parser.add_argument('-show', action="store_true", dest='show', help='show on screen instead of save to file', default=False)
parser.add_argument('-all', action="store_true", dest='all', help=' min max std files of mc', default=False)  # TODO: imporve this
parser.add_argument('-candle', action="store_true", dest='candle', help='plot price candlesticks', default=False)


parser.add_argument(action='store', dest='filename', help='input pickle df file')

args = parser.parse_args()

if args.show:
    import matplotlib.pyplot as plt
    create_plot = lambda _: plt.show()
else:
    import matplotlib
    matplotlib.use('Agg')  # needed on headless machines without xserver
    import matplotlib.pyplot as plt
    def create_plot(name):
        plt.savefig(args.outdir + name + '.png')
        plt.clf()  # clear legend, necessary if we dont provide a new legend for next plot

import pandas as pd  # might import matplotlib, but we need to matplotlib.use('Agg') first

print('input: '+ args.filename)
print('output directory: '+ args.outdir)

df_mean = pd.read_pickle(args.filename)
if args.all:
    df_max = pd.read_pickle(args.filename.strip('mean.pkl') + 'max.pkl')
    df_min = pd.read_pickle(args.filename.strip('mean.pkl') + 'min.pkl')
    df_std = pd.read_pickle(args.filename.strip('mean.pkl') + 'std.pkl')  # standard deviation over all monte carlo runs

#TODO: plot stddev montecarlo runs etc


def plotdata(l, title, xlabel='time (day)', ylabel='', legend=None, lg=False, plot_sum=False, legend_sum=None, filename = ''):
    df_mean[l].plot(logy=lg)
    plt.title(title)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    if plot_sum:
        df_mean[l].sum(axis=1).plot()
        legend.append(legend_sum)
    if legend is not None:
        plt.legend(legend)
    create_plot(filename)

plotdata('price', 'Bitcoin price', ylabel='price (USD)', filename='price')

#TODO candle plot for monte carlo simulations;
# which values to take for max and min??

# see: https://matplotlib.org/examples/pylab_examples/finance_demo.html
if args.candle:
    from matplotlib.finance import candlestick_ohlc
    import numpy as np
    a = np.array(df_mean.index).reshape((-1, 1))
    b = df_mean[['price_open', 'price_max', 'price_min', 'price_close']].values
    data = np.concatenate((a,b), axis=1)
    #TODO merge days and plot less because this way nothing can be seen
    candlestick_ohlc(plt.gca(), data)
    #TODO TODO: plt.xlabel, ylabel title 
    create_plot('candle')

legend_agents = ['miners', 'random traders', 'chartists', 'all agents']
plotdata(['n_miner', 'n_trader', 'n_chartist', 'n_agents'], 'Number of agents', ylabel='number of agents', legend=legend_agents, filename = 'agents')
plotdata(['btc_miner', 'btc_trader', 'btc_chartist'], 'Bitcoins owned by agents', ylabel='number of bitcoins', legend=legend_agents[:3], plot_sum=True, legend_sum = 'Total number of bitcoins', filename = 'bitcoin')
plotdata(['cash_miner', 'cash_trader', 'cash_chartist'], 'Cash owned by agents', ylabel='cash amount (USD)', legend=legend_agents[:3], plot_sum=True, legend_sum = 'Total amount of cash', filename = 'cash')

# calculate wealth
for agent in ['miner', 'trader', 'chartist']:
    df_mean['wealth_'+agent] = df_mean['cash_'+agent] + df_mean['btc_'+agent] * df_mean['price']

# calculate mean over agents
for agent in ['miner', 'trader', 'chartist']:
    for currency in ['cash', 'btc', 'wealth']:
        df_mean[currency+'_' + agent + '_avg'] = df_mean[currency+'_'+agent] / df_mean['n_'+agent]


# TODO: make this nicer
plotdata(['btc_miner_avg', 'btc_trader_avg', 'btc_chartist_avg'], 'Average Bitcoins owned by agents', ylabel='number of bitcoins', legend=legend_agents[:3], filename = 'bitcoin_avg')
plotdata(['cash_miner_avg', 'cash_trader_avg', 'cash_chartist_avg'], 'Average Cash owned by agents', ylabel='cash amount (USD)', legend=legend_agents[:3], filename = 'cash_avg')

plotdata(['wealth_miner', 'wealth_trader', 'wealth_chartist'], 'Agent Wealth', ylabel='$', legend=legend_agents, plot_sum=True, legend_sum = 'Total wealth', filename = 'wealth')
plotdata(['wealth_miner_avg', 'wealth_trader_avg', 'wealth_chartist_avg'], 'Average agent wealth', ylabel='$', legend=legend_agents[:3], filename = 'wealth_avg')

legend_orders = ['sell orders', 'infinite sell orders', 'buy orders']
plotdata(['n_orders_sell_left', 'n_orders_sellinf_left', 'n_orders_buy_left'], 'Number of orders left at end of day', ylabel='number of orders', legend=legend_orders, filename = 'orders')

plotdata('energy_cons_avg', 'Average hashing capability', ylabel='hashing capability per miner (GH/s)', filename = 'energy_avg')
plotdata('energy_cons_total', 'Total energy consumption', ylabel='energy comsumption (W)', lg=True, filename = 'energy_total')

plotdata('hashing_cap_total', 'Total hashing capability', ylabel='hashing capability (GH/s)', lg=True, filename = 'hashing_avg')
#plotdata('btc_mined_avg', 'Average bitcoin income', ylabel='bitcoin income per miner', filename = 'hashing_total')

plotdata('n_transactions', 'Number of transactions', ylabel='number of transactions', filename = 'transactions')
plotdata('transaction_volume_btc', 'Transaction volume', ylabel='transaction volume (#bitcoin)', filename = 'transaction_volume_btc')

plotdata('transaction_volume_cash', 'Transaction volume', ylabel='transaction volume (USD)', filename = 'transaction_volume_cash')


# TODO: re-implement datacollection of electricity_cost and hardware_bought
"""
def getsum6(p):
    dat = list(df_mean[p])
    n = len(dat)
    m = int(np.floor(n/6))
    k = 6*m
    return np.array(dat[:k]).reshape(m, 6).sum(axis=1)

plt.semilogy(getsum6('electricity_cost'))
plt.title('6-day sum of electricity cost')
plt.xlabel('time (6 days)')
plt.ylabel('electricity cost (USD)')
create_plot(...name...)

plt.semilogy(getsum6('hardware_bought'))
plt.title('6-day sum of units of equipment bought')
plt.xlabel('time (6 days)')
plt.ylabel('equipments bought (#)')
create_plot(...name...)
"""
